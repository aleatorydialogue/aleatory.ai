<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Fractal Ray Organism Simulator</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, organisms;
        const organismCount = 4;
        const maxRayLength = 2.5;
        const maxConnections = 8;
        const decayRate = 0.001; // Decay rate for connections
        const boundary = 5;

        class Organism {
            constructor() {
                this.position = new THREE.Vector3(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10
                );
                this.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1,
                    (Math.random() - 0.5) * 0.1
                );
                this.baseColor = new THREE.Color(Math.random(), Math.random(), Math.random());
                this.nodes = [];
                this.connections = [];

                this.object3D = new THREE.Object3D();
                scene.add(this.object3D);

                this.addNode(new THREE.Vector3(0, 0, 0));
            }

            addNode(position) {
                const node = {
                    position: position.clone(),
                    connections: []
                };
                this.nodes.push(node);

                this.nodes.forEach(otherNode => {
                    if (otherNode !== node && otherNode.connections.length < maxConnections && node.connections.length < maxConnections) {
                        const distance = node.position.distanceTo(otherNode.position);
                        if (distance < maxRayLength) {
                            this.addConnection(node, otherNode);
                        }
                    }
                });
            }

            addConnection(node1, node2) {
                const geometry = new THREE.BufferGeometry().setFromPoints([node1.position, node2.position]);
                const material = new THREE.LineBasicMaterial({
                    color: this.baseColor.clone().offsetHSL(Math.random() * 0.1, 0, 0),
                    linewidth: 2
                });
                const line = new THREE.Line(geometry, material);
                this.object3D.add(line);

                const connection = { line, node1, node2, strength: 1 };
                this.connections.push(connection);
                node1.connections.push(connection);
                node2.connections.push(connection);
            }

            update() {
                this.position.add(this.velocity);
                this.object3D.position.copy(this.position);

                ['x', 'y', 'z'].forEach(axis => {
                    if (Math.abs(this.position[axis]) > boundary) {
                        this.velocity[axis] *= -1;
                    }
                });

                this.velocity.add(new THREE.Vector3(
                    (Math.random() - 0.5) * 0.01,
                    (Math.random() - 0.5) * 0.01,
                    (Math.random() - 0.5) * 0.01
                ));

                if (this.velocity.length() > 0.2) {
                    this.velocity.normalize().multiplyScalar(0.2);
                }

                this.connections = this.connections.filter(connection => {
                    connection.strength -= decayRate;
                    if (connection.strength <= 0) {
                        this.object3D.remove(connection.line);
                        connection.node1.connections = connection.node1.connections.filter(conn => conn !== connection);
                        connection.node2.connections = connection.node2.connections.filter(conn => conn !== connection);
                        return false;
                    } else {
                        connection.line.geometry.setFromPoints([
                            connection.node1.position,
                            connection.node2.position
                        ]);
                        connection.line.geometry.attributes.position.needsUpdate = true;
                        return true;
                    }
                });

                this.baseColor.offsetHSL(0.001, 0, 0);
                this.connections.forEach(connection => {
                    connection.line.material.color.offsetHSL(0.002, 0, 0);
                });
            }

            evolve() {
                if (this.nodes.length < 50) {
                    const baseNode = this.nodes[Math.floor(Math.random() * this.nodes.length)];
                    const angle1 = Math.random() * Math.PI * 2;
                    const angle2 = Math.random() * Math.PI;
                    const distance = Math.random() * maxRayLength;
                    const newPosition = new THREE.Vector3(
                        Math.sin(angle1) * Math.cos(angle2),
                        Math.sin(angle1) * Math.sin(angle2),
                        Math.cos(angle1)
                    ).multiplyScalar(distance).add(baseNode.position);
                    this.addNode(newPosition);
                } else {
                    this.nodes.forEach(node => {
                        node.position.add(new THREE.Vector3(
                            (Math.random() - 0.5) * 0.1,
                            (Math.random() - 0.5) * 0.1,
                            (Math.random() - 0.5) * 0.1
                        ));
                    });
                }

                // Add new connections to maintain complexity
                const node1 = this.nodes[Math.floor(Math.random() * this.nodes.length)];
                const node2 = this.nodes[Math.floor(Math.random() * this.nodes.length)];
                if (node1 !== node2 && node1.connections.length < maxConnections && node2.connections.length < maxConnections) {
                    const distance = node1.position.distanceTo(node2.position);
                    if (distance < maxRayLength) {
                        this.addConnection(node1, node2);
                    }
                }

                this.baseColor.offsetHSL(Math.random() * 0.1, 0, 0);
            }
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 15;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            organisms = Array.from({ length: organismCount }, () => new Organism());

            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function checkCollisions() {
            for (let i = 0; i < organisms.length; i++) {
                for (let j = i + 1; j < organisms.length; j++) {
                    const distance = organisms[i].position.distanceTo(organisms[j].position);
                    if (distance < maxRayLength * 2) {
                        organisms[i].evolve();
                        organisms[j].evolve();
                    }
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            organisms.forEach(organism => organism.update());
            checkCollisions();

            camera.position.x = Math.sin(Date.now() * 0.0001) * 15;
            camera.position.z = Math.cos(Date.now() * 0.0001) * 15;
            camera.lookAt(scene.position);

            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>
